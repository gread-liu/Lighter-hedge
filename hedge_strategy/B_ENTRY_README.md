# B入口实现说明

## 概述

B入口是对冲策略的订阅端，负责监听A入口的成交消息并执行市价对冲操作。

## 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    B入口架构（蓝色部分）                       │
└─────────────────────────────────────────────────────────────┘

                    main_B.py
                        │
                        ├─── 初始化B账户客户端
                        │
                        ├─── 初始化Redis连接
                        │
                        ├─── 订阅A账户成交消息
                        │    (hedge:account_a_filled)
                        │
                        └─── 进入监听循环
                             │
                             ↓
                    ┌────────────────┐
                    │  Redis订阅监听  │
                    └────────────────┘
                             │
                             │ 收到A账户成交消息
                             ↓
                    ┌────────────────┐
                    │ AccountBManager│
                    │ on_a_account_  │
                    │    filled()    │
                    └────────────────┘
                             │
                             ↓
                    ┌────────────────┐
                    │  执行市价对冲   │
                    │  (做空订单)    │
                    └────────────────┘
                             │
                             ↓
                    ┌────────────────┐
                    │ 推送对冲完成    │
                    │ 消息到Redis    │
                    └────────────────┘
```

## 核心文件

### 1. main_B.py
B入口的主程序，负责：
- 初始化B账户客户端
- 连接Redis并订阅A账户成交消息
- 保持监听状态
- 处理优雅退出

**关键特性**：
- 纯订阅模式，不主动挂单
- 事件驱动架构
- 自动重连机制

### 2. account_b_manager.py
B账户管理器，负责：
- 接收A账户成交通知
- 执行市价对冲订单
- 重试机制（默认3次）
- 推送对冲完成消息

**核心方法**：
- `on_a_account_filled()`: Redis消息回调
- `_execute_hedge()`: 执行对冲逻辑
- `_create_market_sell_order()`: 创建市价卖单
- `_notify_hedge_completed()`: 通知对冲完成

### 3. redis_messenger.py
Redis消息管理器，负责：
- 发布/订阅消息
- 消息格式化
- 连接管理

**使用的Channel**：
- `hedge:account_a_filled`: A账户成交通知（订阅）
- `hedge:account_b_filled`: B账户对冲完成通知（发布）

## 消息格式

### A账户成交消息（订阅）
```json
{
    "account_index": 280459,
    "market_index": 1,
    "order_index": 12345,
    "filled_base_amount": "0.01",
    "filled_quote_amount": "30.24",
    "avg_price": "3024.00",
    "timestamp": 1234567890,
    "side": "buy"
}
```

### B账户对冲完成消息（发布）
```json
{
    "account_index": 280458,
    "market_index": 1,
    "order_index": 12346,
    "filled_base_amount": "0.01",
    "filled_quote_amount": "30.22",
    "avg_price": "3022.00",
    "timestamp": 1234567891,
    "side": "sell"
}
```

## 工作流程

1. **启动阶段**
   - 加载配置文件
   - 初始化B账户客户端
   - 连接Redis
   - 订阅A账户成交channel
   - 进入监听模式

2. **监听阶段**
   - 保持Redis连接
   - 等待A账户成交消息
   - 定期健康检查

3. **对冲阶段**（收到消息后触发）
   - 解析A账户成交信息
   - 创建市价卖单（做空）
   - 等待订单成交
   - 验证成交结果
   - 推送对冲完成消息

4. **重试机制**
   - 对冲失败自动重试（最多3次）
   - Nonce错误自动刷新重试
   - 网络错误延迟重试

## 配置说明

### config.yaml
```yaml
accounts:
  account_b:
    api_key_private_key: "your_private_key"
    account_index: 280458
    api_key_index: 2

redis:
  host: "localhost"
  port: 6388
  db: 0

strategy:
  retry_times: 3  # 对冲失败重试次数
```

## 启动方式

### 方式1：直接启动
```bash
python main_B.py --market ETH --config config.yaml
```

### 方式2：使用启动脚本
```bash
# Windows
start_hedge.bat

# Linux/Mac
./start_hedge.sh
```

## 监控和调试

### 查看日志
```bash
# 实时查看日志
tail -f logs/main_B.log

# 查看最近的日志
tail -n 100 logs/main_B.log
```

### Redis监控
```bash
# 连接Redis
redis-cli -p 6388

# 监控所有消息
PSUBSCRIBE hedge:*

# 监控特定channel
SUBSCRIBE hedge:account_a_filled
```

### 关键日志标识
- `[INFO]`: 正常运行信息
- `[WARNING]`: 警告信息（如重试）
- `[ERROR]`: 错误信息（需要关注）

## 异常处理

### 1. Redis连接断开
- 自动尝试重新连接
- 记录警告日志
- 不影响程序运行

### 2. 对冲失败
- 自动重试3次
- 每次重试间隔1秒
- 所有重试失败后记录错误并抛出异常

### 3. Nonce错误
- 自动刷新nonce管理器
- 重试订单创建
- 最多重试3次

### 4. 市场流动性不足
- 市价单可能部分成交
- 检查订单状态
- 记录实际成交量

## 性能优化

1. **异步处理**
   - 使用asyncio异步框架
   - 非阻塞式消息处理
   - 并发处理多个对冲请求

2. **连接复用**
   - Redis连接保持
   - API客户端复用
   - 减少连接开销

3. **快速响应**
   - 市价单立即成交
   - 最小化延迟
   - 优化网络请求

## 安全考虑

1. **账户隔离**
   - B账户独立部署
   - 不同IP地址
   - 独立的API密钥

2. **资金管理**
   - 确保充足余额
   - 监控账户状态
   - 设置告警阈值

3. **错误恢复**
   - 优雅退出机制
   - 自动取消挂单
   - 清理资源

## 与A入口的协同

### 消息流
```
A入口                    Redis                    B入口
  │                       │                       │
  │ 1. 限价单成交          │                       │
  │────────────────────→  │                       │
  │                       │                       │
  │ 2. 推送成交消息        │                       │
  │────────────────────→  │                       │
  │                       │  3. 订阅收到消息       │
  │                       │────────────────────→  │
  │                       │                       │
  │                       │  4. 执行市价对冲       │
  │                       │  ←────────────────────│
  │                       │                       │
  │                       │  5. 推送对冲完成       │
  │                       │←────────────────────  │
  │  6. 收到对冲完成       │                       │
  │←────────────────────  │                       │
  │                       │                       │
  │ 7. 继续下一轮          │                       │
```

### 时序要求
- B入口应先于A入口启动
- 确保Redis订阅已建立
- A入口才开始挂单

## 故障排查

### 问题1：收不到消息
**症状**：B入口启动正常，但收不到A账户成交消息

**排查步骤**：
1. 检查Redis是否正常运行
2. 确认config.yaml中Redis配置正确
3. 使用redis-cli测试订阅
4. 检查A入口是否正常推送消息

### 问题2：对冲失败
**症状**：收到消息但对冲订单创建失败

**排查步骤**：
1. 检查B账户余额
2. 查看具体错误日志
3. 确认市场流动性
4. 检查网络连接

### 问题3：重复对冲
**症状**：同一笔成交被对冲多次

**排查步骤**：
1. 检查是否启动了多个B入口实例
2. 确认Redis消息没有重复发送
3. 检查订单去重逻辑

## 测试建议

### 单元测试
```bash
# 测试Redis连接
python -c "from redis_messenger import RedisMessenger; m = RedisMessenger(); m.connect(); print('OK')"

# 测试B账户连接
python -c "import lighter; client = lighter.SignerClient(...); print('OK')"
```

### 集成测试
1. 启动Redis
2. 启动B入口
3. 手动发送测试消息
4. 验证对冲执行

### 压力测试
- 模拟高频成交消息
- 测试并发对冲能力
- 监控系统资源使用

## 部署建议

### 生产环境
1. 使用独立服务器
2. 配置监控告警
3. 设置日志轮转
4. 定期备份配置

### 高可用
1. Redis主从复制
2. B入口多实例部署
3. 负载均衡
4. 故障自动切换

## 更新日志

### v1.0.0 (2024-01-23)
- 初始版本
- 实现基本的订阅和对冲功能
- 支持市价单对冲
- 添加重试机制